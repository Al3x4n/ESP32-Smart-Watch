boolean correctTime = false;
RTC_DATA_ATTR time_t now;
RTC_DATA_ATTR uint64_t Mics = 0;
RTC_DATA_ATTR struct tm * timeinfo;


String getInternetTime() {
  //connect to WiFi
  int wifiCounter = 0;
#ifdef DEBUG
  Serial.println("Connecting to %s ", ssid);
#endif
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
#ifdef DEBUG
    Serial.print(".");
#endif
    if (++wifiCounter > 30) ESP.restart(); // restart after 15 s
  }
  Serial.println(" CONNECTED");
  //init and get the time
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  delay(1000);
  printLocalTime();
  unsigned long chrono = micros();
  //disconnect WiFi as it's no longer needed
  WiFi.disconnect(true);
  WiFi.mode(WIFI_OFF);
  bootCount++;
  sommeil (chrono);
  return "00:00:00AM";
}

void printLocalTime() {
  time(&now);
  timeinfo = localtime (&now);
  Serial.printf ("%s\n", asctime(timeinfo));
  delay(2); // 26 bytes @ 115200 baud is less than 2 ms
}

void updateTime (uint64_t elapsedTime) { // elapsedTime in us
  if (elapsedTime == 0) Mics += micros();
  else Mics += elapsedTime;
  if (Mics > 1000000) {
    Mics = Mics % 1000000;
    now += Mics / 1000000;
  }
}

void sommeil (unsigned long chrono) {
  updateTime (sleepPeriod - (micros() - chrono) + OFFSET);
  esp_sleep_enable_timer_wakeup(sleepPeriod - (micros() - chrono));
  esp_deep_sleep_start();
}



void drawDate(int x, int y, int textSize) {

}



void drawDateCentered(int y, int textSize) {

}

void drawTime(int x, int y, int textSize)
{


}
